/* tslint:disable */
/* eslint-disable */
/**
 * World of Tanks
 * OpenAPI specification for the Wargaming.net Public API. The official Wargaming.net Public API documentation can be found at the Wargaming [Developer\'s room](https://developers.wargaming.net/).
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact@ace-tanker.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime.js';
import type {
  GetAuthLogin200Response,
  Logout200Response,
  Prolongate200Response,
} from '../models/index.js';
import {
    GetAuthLogin200ResponseFromJSON,
    GetAuthLogin200ResponseToJSON,
    Logout200ResponseFromJSON,
    Logout200ResponseToJSON,
    Prolongate200ResponseFromJSON,
    Prolongate200ResponseToJSON,
} from '../models/index.js';

export interface GetAuthLoginRequest {
    display?: GetAuthLoginDisplayEnum;
    expiresAt?: number;
    nofollow?: number;
    redirectUri?: string;
}

export interface LogoutRequest {
    accessToken: string;
}

export interface ProlongateRequest {
    accessToken: string;
    expiresAt?: number;
}

/**
 * 
 */
export class AuthenticationApi extends runtime.BaseAPI {

    /**
     * Method authenticates user based on Wargaming.net ID (OpenID) which is used in World of Tanks, World of Tanks Blitz, World of Warships, World of Warplanes, and WarGag.ru. To log in, player must enter email and password used for creating account, or use a social network profile. Authentication is not available for iOS Game Center users in the following cases: *  the account is not linked to a social network account, or *  email and password are not specified in the profile.  Information on authorization status is sent to URL specified in **redirect_uri** parameter.  If authentication is successful, the following parameters are sent to **redirect_uri**:  *  **status: ok** — successful authentication *  **access_token** — access token is passed in to all methods that require authentication *  **expires_at** — expiration date of **access_token** *  **account_id** — user ID *  **nickname** — user name.  If authentication fails, the following parameters are sent to **redirect_uri**:  *  **status: error** — authentication error *  **code** — error code *  **message** — error message.
     * OpenID login
     */
    async getAuthLoginRaw(requestParameters: GetAuthLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAuthLogin200Response>> {
        const queryParameters: any = {};

        if (requestParameters['display'] != null) {
            queryParameters['display'] = requestParameters['display'];
        }

        if (requestParameters['expiresAt'] != null) {
            queryParameters['expires_at'] = requestParameters['expiresAt'];
        }

        if (requestParameters['nofollow'] != null) {
            queryParameters['nofollow'] = requestParameters['nofollow'];
        }

        if (requestParameters['redirectUri'] != null) {
            queryParameters['redirect_uri'] = requestParameters['redirectUri'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["application_id"] = await this.configuration.apiKey("application_id"); // application_id authentication
        }


        let urlPath = `/auth/login/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetAuthLogin200ResponseFromJSON(jsonValue));
    }

    /**
     * Method authenticates user based on Wargaming.net ID (OpenID) which is used in World of Tanks, World of Tanks Blitz, World of Warships, World of Warplanes, and WarGag.ru. To log in, player must enter email and password used for creating account, or use a social network profile. Authentication is not available for iOS Game Center users in the following cases: *  the account is not linked to a social network account, or *  email and password are not specified in the profile.  Information on authorization status is sent to URL specified in **redirect_uri** parameter.  If authentication is successful, the following parameters are sent to **redirect_uri**:  *  **status: ok** — successful authentication *  **access_token** — access token is passed in to all methods that require authentication *  **expires_at** — expiration date of **access_token** *  **account_id** — user ID *  **nickname** — user name.  If authentication fails, the following parameters are sent to **redirect_uri**:  *  **status: error** — authentication error *  **code** — error code *  **message** — error message.
     * OpenID login
     */
    async getAuthLogin(requestParameters: GetAuthLoginRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAuthLogin200Response> {
        const response = await this.getAuthLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Method deletes user\'s **access_token**.  After this method is called, **access_token** becomes invalid.
     * Log out
     */
    async logoutRaw(requestParameters: LogoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Logout200Response>> {
        if (requestParameters['accessToken'] == null) {
            throw new runtime.RequiredError(
                'accessToken',
                'Required parameter "accessToken" was null or undefined when calling logout().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["application_id"] = await this.configuration.apiKey("application_id"); // application_id authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['accessToken'] != null) {
            formParams.append('access_token', requestParameters['accessToken'] as any);
        }


        let urlPath = `/auth/logout/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Logout200ResponseFromJSON(jsonValue));
    }

    /**
     * Method deletes user\'s **access_token**.  After this method is called, **access_token** becomes invalid.
     * Log out
     */
    async logout(requestParameters: LogoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Logout200Response> {
        const response = await this.logoutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Method generates new **access_token** based on the current token.  This method is used when the player is still using the application but the current **access_token** is about to expire.
     * Access Token extension
     */
    async prolongateRaw(requestParameters: ProlongateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Prolongate200Response>> {
        if (requestParameters['accessToken'] == null) {
            throw new runtime.RequiredError(
                'accessToken',
                'Required parameter "accessToken" was null or undefined when calling prolongate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["application_id"] = await this.configuration.apiKey("application_id"); // application_id authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['accessToken'] != null) {
            formParams.append('access_token', requestParameters['accessToken'] as any);
        }

        if (requestParameters['expiresAt'] != null) {
            formParams.append('expires_at', requestParameters['expiresAt'] as any);
        }


        let urlPath = `/auth/prolongate/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Prolongate200ResponseFromJSON(jsonValue));
    }

    /**
     * Method generates new **access_token** based on the current token.  This method is used when the player is still using the application but the current **access_token** is about to expire.
     * Access Token extension
     */
    async prolongate(requestParameters: ProlongateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Prolongate200Response> {
        const response = await this.prolongateRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetAuthLoginDisplayEnum = {
    Page: 'page',
    Popup: 'popup'
} as const;
export type GetAuthLoginDisplayEnum = typeof GetAuthLoginDisplayEnum[keyof typeof GetAuthLoginDisplayEnum];
